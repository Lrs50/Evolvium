from typing import Union, Tuple, Any
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
from evolvium.algorithms.genetic.individual import Individual, SHARED
from evolvium.algorithms.genetic.operators import roulette, slow_transition


def run(
    max_gen: int = 100,
    pop_size: int = 30,
    prole_size: int = 10,
    mutation_rate: Union[float, Tuple[float, float]] = 1 / 30,
    stop: float = 0.5,
    verbose: bool = False,
    **kwargs: Any,
) -> Individual:
    """
    Run the genetic algorithm for a specified number of generations to evolve a population.

    This function implements a complete genetic algorithm pipeline that evolves a population
    of individuals over multiple generations using selection, crossover, and mutation operations.
    The algorithm tracks fitness evolution and can terminate early when a fitness threshold is met.

    Args:
        max_gen (int, optional): Maximum number of generations to run. Defaults to 100.
        pop_size (int, optional): Size of the population in each generation. Defaults to 30.
        prole_size (int, optional): Number of offspring generated by crossover per generation.
            Defaults to 10.
        mutation_rate (Union[float, Tuple[float, float]], optional): Mutation rate. If float,
            constant rate is used. If tuple, rate transitions from first to second value over
            generations. Defaults to 1/30.
        stop (float, optional): Fitness threshold for early termination. Algorithm stops when
            best fitness is <= this value. Defaults to 0.5.
        verbose (bool, optional): Whether to display detailed progress information and generate
            fitness evolution plots. Defaults to False.
        **kwargs: Additional attributes for customization, with their defaults:
            - metric (Callable): Fitness evaluation function. Default: default_metric
            - repr (Callable): String representation function. Default: default_repr
            - gene_type (str): Type of genes ('binary', 'integer', 'real'). Default: 'integer'
            - gene_size (int): Number of genes in the chromosome. Default: 10
            - gene_upper_limit (int|float): Upper limit for gene values. Default: 10
            - init_method (str): Initialization method ('random', 'mix', 'zeros'). Default: 'random'
            - mutation_type (str): Mutation strategy. Default: 'random range'
            - mutation_range (tuple): Range for mutation values (low, high). Default: (-1, 1)
            - crossover_type (str): Crossover strategy (random mix, split, avg). Default: 'split'
            - chromosome_size (int): Size of each chromosome segment. Default: 1

    Returns:
        Individual: The best individual found across all generations.

    Raises:
        ValueError: If invalid parameters are provided to Individual initialization.

    Example:
        >>> # Basic usage with default parameters
        >>> best = run(max_gen=50, pop_size=20, verbose=True)

        >>> # Custom fitness function and gene configuration
        >>> def my_fitness(genes):
        ...     return sum(genes ** 2)  # Minimize sum of squares
        >>>
        >>> best = run(
        ...     max_gen=100,
        ...     pop_size=50,
        ...     mutation_rate=(0.1, 0.01),  # Decrease mutation over time
        ...     metric=my_fitness,
        ...     gene_type='real',
        ...     gene_size=20
        ... )

    Notes:
        - Uses roulette wheel selection for parent selection
        - Fitness caching is automatically enabled to avoid redundant evaluations
        - Population diversity is tracked and displayed in verbose mode
        - Early termination occurs when fitness threshold is reached
        - Fitness evolution plot is shown when verbose=True
    """

    cache_size = kwargs.get("cache_size", 1000)
    debug_func = kwargs.get("debug_func", None)

    SHARED.cache.size = cache_size

    SHARED.fitness_calls = 0
    SHARED.total_fitness_calls = 0

    if isinstance(mutation_rate, tuple):
        mutation_list = slow_transition(mutation_rate[0], mutation_rate[1], max_gen)
    else:
        mutation_list = np.ones(max_gen) * mutation_rate

    fitness_list_best = []
    fitness_list_avg = []

    pop = []
    pbar = tqdm(list(range(pop_size)))

    for i in pbar:
        pop.append(Individual(**kwargs))
        pbar.set_description(
            f"Loading Initial Population | {pop[i]} |Current Fitness = {pop[i].fitness:.2e}"
        )

    pop.sort(key=lambda x: x.fitness)
    best_global = pop[0].copy()
    if verbose and debug_func:
        debug_func(best_global.gene)

    pbar = tqdm(list(range(max_gen)))

    for gen in pbar:

        diversity = {str(p) for p in pop}
        mutation_rate = mutation_list[gen]

        fitness_list = [ind.fitness for ind in pop]

        if best_global.fitness > pop[0].fitness:
            best_global = pop[0].copy()
            if verbose and debug_func:
                debug_func(best_global.gene)

            if best_global.fitness <= stop:
                break

        best = best_global.fitness
        avg = np.mean(fitness_list)
        fitness_list_avg.append(avg)
        fitness_list_best.append(best)

        if verbose:
            pbar.set_description(
                f"AVG = {avg:.2e} | BEST = {best:.2e} | D = {len(diversity)/pop_size:.2f} |{best_global} |Calls {SHARED.fitness_calls:5d} | {SHARED.total_fitness_calls:5d} | Mutation Rate = {mutation_rate:.2%}"
            )
        else:
            pbar.set_description(f"AVG = {avg:.2e} | BEST = {best:.2e}")

        survivors = roulette(fitness_list.copy(), pop.copy(), pop_size - prole_size)

        new_gen = [s.mutate(mutation_rate) for s in survivors]

        for _ in range(prole_size):
            parents = roulette(fitness_list, pop, 2)
            mum = parents[0]
            dad = parents[1]
            kid = mum.crossover(dad).mutate(mutation_rate)
            new_gen.append(kid)

        new_gen.sort(key=lambda x: x.fitness)
        pop = new_gen[:pop_size]

    if verbose:
        plt.figure(figsize=(20, 6))
        plt.suptitle("Genetic Algorithm Evolution Graph", fontsize=25)
        plt.plot(fitness_list_best, "--", color="lightsteelblue", label="Best")
        plt.plot(fitness_list_avg, "--", color="lightcoral", label="Average")
        plt.xlabel("Generation")
        plt.ylabel("Fitness")
        plt.legend()
        plt.show()

    return best_global
